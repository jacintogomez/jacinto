<!DOCTYPE html>
<html lang='en-us'>
<meta name='viewport' content='width=device-width,initial-scale=1.0'>
<head>
  <title>Algo Tracer</title>
  <link rel="icon" href="https://paper-attachments.dropbox.com/s_2D428973624E7FC84C7D69D11421DE762BEA6B6F3361231FCDCAE0425D14526F_1664885448372_Untitled.drawio+17.png">
  <style>
  	.fancy{
    	color: white;
        text-shadow: 1px 1px 2px black, 0 0 25px blue, 0 0 5px darkblue;
	  }
    .error{
    	color: white;
        text-shadow: 1px 1px 2px black, 0 0 25px red, 0 0 5px darkred;
	  }
    .surround{
      border: 2px solid;
      border-radius: 5px;
    }
    .lefthalf{
        width:35%;
        float: left;
        display: inline-block;
        text-align: center;
    }
    .righthalf{
        width:65%;
        float: left;
        display: inline-block;
        text-align: center;
    }
    .hidden {
      display: none;
    }
    input:hover{
      border: 1px solid aqua;
      box-shadow: 5px 10px 18px black;
    }
    .center{
      margin: 0;
      position: absolute;
      left: 50%;
      -ms-transform: translate(-50%,-50%);
      transform: translate(-50%,-50%);
    }
    body {
      background-image: url("https://marketplace.canva.com/EAD2962NKnQ/2/0/1600w/canva-rainbow-gradient-pink-and-purple-zoom-virtual-background-_Tcjok-d9b4.jpg");
      background-repeat: no-repeat;
      background-size: cover;
    }
    .console{
        background-color: black;
        color: white;
        font-family: monospace;
        height: 2000px;
        width: 900px;
        position: absolute;
        overflow-y: auto;
        resize: vertical;
        text-align: left;
    }
  </style>
</head>
<body>
<h1 style='text-align:center;'>Trace Your Sorting Algorithm</h1>
<h5 style='text-align:center;'>Created by Jacinto Gomez</h5>
<h4 style='text-align:center;'>Select an algorithm to the right and enter an array to watch it be sorted step by step<br>The left has some descriptions of how the algorithms work</h4>
<br><br>
<div class="lefthalf">
    <h3>Mergesort</h3>
    <h6>Recursive. This breaks the array into 2 smaller arrays, then those into 2 more smaller arrays, and continues until the base case of an array of size 1 is reached,
        then merges these auxiliary arrays in sorted order. This ends up being efficient since each auxiliary array
        going up the call stack will already be in sorted order.</h6>
    <h5 style="font-family:monospace;">Time Complexity: Theta(n*log(n))</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(n)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Insertion Sort</h3>
    <h6>For each element, insert it into the sorted portion by pushing it back until it's in the proper spot.</h6>
    <h5 style="font-family:monospace;">Time Complexity: Omega(n), Theta(n^2), O(n^2)</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(1)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Selection Sort</h3>
    <h6>Go through the unsorted portion of the array to select the next smallest element, and swap with the current.</h6>
    <h5 style="font-family:monospace;">Time Complexity: Theta(n^2)</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(1)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Bubble Sort</h3>
    <h6>Compare side by side elements and swap if the left one is larger; with each trial of this the next largest
        element 'bubbles' to the top. This needs to be done for n passes, since each pass only brings the
        next largest element to the top.</h6>
    <h5 style="font-family:monospace;">Time Complexity: Omega(n), Theta(n^2), O(n^2)</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(1)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Quicksort</h3>
    <h6>Recursive. For each call, a random element (we refer to as the pivot) is chosen and all elements less than it are
        placed to the left, and all elements greater are placed to the right. It is then recursively called on both of those two halves.
        A partition function is called in each iteration to select the pivot, which can make it either a random selection or a fixed array index (here it is fixed, the last index).</h6>
    <h5 style="font-family:monospace;">Time Complexity: Omega(n*log(n)), Theta(n*log(n)), O(n^2)</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(n*log(n))</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Heapsort</h3>
    <h6>This forms a max heap (a tree but with the condition that a parent is greater than a child),
        and for each node starting from the last leaf, switches it with the root node and calls
        a function called heapify, which restructures the tree so that the max element is on top again. Each time a max
        element is removed, it is essentially at the end of an array; in other words, is now in sorted position. It should
        be noted that heapsort itself is not recursive, but it calls heapify which is.</h6>
    <h5 style="font-family:monospace;">Time Complexity: Theta(n*log(n))</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(1)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Counting Sort</h3>
    <h6>Creates two new arrays, one counting the frequency of occurrence of each number in the array (then adjusted
        to represent the array index), and the other to hold the output array. The output array at index i is updated with the
        value of indexarray[originalarray[i]] for each i in range n. This results in linear runtime, but it only works
        if the range of numbers is known beforehand. This is also a stable sort, meaning the order of repeated values doesn't change</h6>
    <h5 style="font-family:monospace;">Time Complexity: Theta(n+k), k=range of possible values</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(k)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Radix Sort</h3>
    <h6>This will first sort all elements by the digit in the 1's place, then by the digit in the 10's place.. continuing
          through to the last digit. The sorting is done with some stable sorting algorithm (counting sort, for example).</h6>
    <h5 style="font-family:monospace;">Time Complexity: Theta(d(n+k)), d=max # of digits, k=base of whatever number we are using (usually 10)</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(n+k)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Bucket Sort</h3>
    <h6>Adjust input so they are all in range [0:1), and divide range into buckets where certain ranges of values will go.
          Each of these buckets, which are ideally near-sorted, are then sorted using insertion sort and concatenated.</h6>
    <h5 style="font-family:monospace;">Time Complexity: Omega(n+k), Theta(n+k), O(n^2), k=# of buckets</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(n)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
    <h3>Bogosort</h3>
    <h6>Creates a random permutation the array and sees if it is sorted or not; repeats this until sorted. You would
        never use this in real life, it is just a common thought experiment that I included for fun.</h6>
    <h5 style="font-family:monospace;">Time Complexity: Omega(0), Theta(n*(n!)), O(Infinity)</h5>
    <h5 style="font-family:monospace;">Space Complexity: O(1)</h5>
    <h5>---------------------------------------------------------------------------------------------------------</h5>
</div>
<div class="righthalf">
<div class=''>
    <label for="algos">Choose an algorithm:</label>
    <select name="algos" id="algos" onchange="toggleTextInput()">
    <option value="merge">Mergesort</option>
    <option value="insert">Insertion Sort</option>
    <option value="select">Selection Sort</option>
    <option value="bubble">Bubble Sort</option>
    <option value="quick">Quicksort</option>
    <option value="heap">Heapsort</option>
    <option value="count">Counting Sort</option>
    <option value="radix">Radix Sort</option>
    <option value="bucket">Bucket Sort</option>
    <option value="bogo">Bogosort</option>
  </select>
  <br><br>
      <input type='text' id='inputfield' style="width:250px;" placeholder='example: enter [3,1,2] as 3 1 2'><br><br>
      <div id="numbuckets" class="hidden">
          <h4>If you want to choose your number of buckets then enter it below,<br>otherwise enter 0 to use the square root of n</h4>
        <input type="text" id="tinput" placeholder="# of buckets">
      </div>
      <button onclick='main(document.getElementById("algos").value,document.getElementById("inputfield").value,document.getElementById("tinput").value)'>Sort</button>
    <br><br>
  <div class='console' id="output"></div>
    </div>
</div>
  <script src="sorting.js">
  </script>
</body>
</html>